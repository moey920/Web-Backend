# Flask의 기본 구조

## 1. HTTP(언어)란

- 서버를 가지고 통신할 때, HTTP라는 언어로 통신(대화)한다고 생각하기

## 2. Method(동사)

- Server, Client 중 동사의 주체가 누구인지 잘 알아야 한다. 고객 기준이라고 생각하기. 항상 기준은 Client(고객)이 왕이다.
- Server(주세요), Client(줄게요!)
- 정보의 교환이 목적이다 보니 대부분 Get(주세요), Post(줄게요)로 구현이 가능하다.

## 3. STATE(상태)

- 1) Clinet(POST) -> Server
- 2) Client <- Server
- 3) Client(POST) -> Server

> 3은 1에서 무슨 정보를 서버에게 주었는지 기억하지 못한다. HTTP는 기억 능력이 없다. 네이버에 로그인 하고, 이후에 요청할 때 이전 로그인에 대한 정보를 저장하지 않는다. -> 쿠키(클라이언트), 세션(서버) 등의 방법이 나왔다.

## 4. 간단한 Flask를 통해 Get, Post 이해하기

### index.html
```
<html>
  <head>
    <title>Elice</title>
  </head>
    <!-- app.py에서 user_id를 받아온다 -->
    <!-- Flask에서 template을 이용하는 독특한 방법이 있다. -->
  <body>
    <h1>Index.html</h1>
    <p>{{ user_id }}</p>
  </body>
</html>
```

### home.html
```
<!doctype html>
<html>
<head>
<title>Home</title>
</head>
<body>
    <h1>Home.html</h1>
    {% for title in titles %}
    <p>{{ title }}</p>
    {% endfor %}

    <form action='/register' method="POST">
    id <input type="text" name="user_id"/>
    password <input type="password" name="user_pw"/>
    <input type="submit">
    </form>
    
    <a href="{{ url_for('elice') }}">Go to Elice page</a> 
    <!-- elice()를 실행하라, 경로를 찾는게 아닌 app.py에 있는 함수를 찾는 것이다. -->

</body>
</html>
```

### app.py
```
# 기본 flask 구조에 대해 익혀보아요!
# 파이썬으로 서버를 개발한다고 하면 1. Flask(소규모), 2. Django(대규모)
from flask import Flask, render_template, request, url_for
# request는 사용자의 정보를 가져오거나, 줄 때 사용하는 클래스


app = Flask(__name__) # Flask라는 객체를 만들기. 
# __name__ 은 현재 실행하고 있는 파일을 가르키고 있는 파이썬의 문법이다.
# 현재는 app.py를 가르킨다, app.py를 플라스크 서버로 설정한다


# @app.route('/', method=['GET'])이 default이다. 클라이언트가 get을 한다고 생각하기! 
@app.route('/') # @ : 데코레이터. route는 URL 경로를 의미한다. 해당 주소를 들어가면, 하단의 함수를 실행해라. 함수는 호출시 실행하는 것이 일반적이지만 Flask는 정의만 한다.
@app.route('/home') # home으로 들어온 사람에게도 '/'로 들어온 사람과 같은 것을 반환한다.
def home():
    titles = ['Elice Flask class day1', 'haram good']
    return render_template("home.html", titles = titles) # 기본경로로 들어오면 home.html을 반환하겠다. 다만 반드시 같은 경로의 templates라는 폴더 안에 있어야한다.
    # 클라이언트(브라우저) 입장에서는 home.html이 어디있는지 관심 없다. 서버가 알아서 template폴더에서 찾아서 반환한다.


# @app.route('/user') 
# def user():
#     # 미리 만들어 놓은 html을 반환하고 싶으면 어떻게할까? 
#         # render_template 이용
#     return render_template("index.html")

# 유저가 100명일 때 각 유저에 대한 정보를 보여주고 싶을 땐? API를 활용
@app.route('/user/<username>')
def user(username): # 함수에서 인자도 받아와야한다.
    print(username) # 터미널에 기록을 남기는 print는 로그 용으로 사용하곤 한다.
    return render_template("index.html", user_id = username) # 템플릿 문법

@app.route('/elice') 
def elice():
    return "Hello elice"


# 회원가입, html의 form 태그를 이용
@app.route('/register', methods = ['POST']) # 클라이언트 정보를 줄게요
def register() :
    username = request.form['user_id'] # home.html이 아니라, 어느 html에서든 post를 user_id로 한 것을 찾는다.
    password = request.form['user_pw']
    print(username, password)
    return "Registered!" # 입력 완료 후 /register로 이동하게 된다.

if __name__ == "__main__":
    app.run(debug=True)
```

# Hash

```
# HASH란 무엇인지 살펴봅시다 :)
# 닭 -> 치킨 : 가능 / 치킨 -> 닭 : 불가능, 단 방향성 암호화이다. rainbow table 등의 해킹 기법이 있기는 하다.
# 같은 닭이지만 만들어지는 치킨은 항상 다르다. 
import secrets
from werkzeug.security import generate_password_hash, check_password_hash

# print(secrets.token_hex(16))

chicken = "rohharam"
name = "haram"
fried_chicken_1 = generate_password_hash(chicken) # chicken : 닭, fried_chicken_1 : 치킨
fried_chicken_2 = generate_password_hash(chicken)
print(fried_chicken_1)
print(fried_chicken_2)

print(check_password_hash(fried_chicken_1, chicken)) # 치킨으로 프라이드 치킨 만든게 맞는지 체크
print(check_password_hash(fried_chicken_2, name))
```

# AJAX : 인증, 토큰과 관련

# Local 개발 환경 구축하기

## 프로젝트 폴더 구조 – elice_flask_board 패키지를 구성
```
/elice_flask_board
  /static # css, js 파일이 저장되는 공간
    style.css # 웹 페이지의 스타일 코드(CSS)
  /templates # html 파일이 저장되는 공간
    /auth # 로그인 관련 html 파일이 저장되는 공간
      login.html # 로그인 화면
      register.html # 회원가입 화면
    /board # 게시판 관련 html이 저장되는 공간
      /create.html # 게시글 생성 화면
      /index.html # 게시글 조회 화면
      /update.html # 게시글 수정 화면
    base.html # 모든 html의 header
  auth.py # 로그인 관련 기능을 구현하는 모듈
  board.py # 게시판 관련 기능을 구현하는 모듈
  db.py # 데이터베이스 관련 기능을 구현하는 모듈
  schema.sql # 데이터베이스 스키마를 저장
  __init__.py # 웹 애플리케이션을 실행하는 모듈
```

## 데이터베이스 스키마 만들기

> flask_project/elice_flask_board/db.sql

```
drop table if exists board;

create table board (
  id integer primary key autoincrement,
  title text not null,
  ‘text’ text not null
);
```

## 애플리케이션 설정하기

```
# Flask 애플리케이션 인스턴스 생성
# app.instance_path와 관련된 옵션을 True로 설정
app = Flask(__name__, instance_relative_config=True)

# Flask 애플리케이션 개발을 위한 KEY와 DATABASE 선언
app.config.from_mapping(
  SECRET_KEY='dev',
  # app.instance_path 는 외부로 유출되면 안되는 정보를 저장한다.
  DATABASE=os.path.join(app.instance_path, \
    'elice_flask_board.sqlite'),
)

if test_config is None:
  # 테스트를 실행하지 않을 때, 인스턴스의 설정을 불러옵니다.
  app.config.from_pyfile('config.py', silent=True)
else:
  # 테스트를 실행했을 때
  app.config.from_mapping(test_config)

# 인스턴스 폴더가 있는지 확인합니다. 없다면 에러가 발생합니다.
try:
  os.makedirs(app.instance_path)
except OSError:
  pass
```

## 라우팅 설정하기

> 라우팅이란 사용자가 특정 URL로 접속했을 때, 특정 정보나 페이지를 보여줄 수 있도록 설정하는 것을 뜻함

```
@app.route(‘/hello')
def hello():
  return 'Hello, Elice!'
```
