# Flask의 기본 구조

## 1. HTTP(언어)란

- 서버를 가지고 통신할 때, HTTP라는 언어로 통신(대화)한다고 생각하기

## 2. Method(동사)

- Server, Client 중 동사의 주체가 누구인지 잘 알아야 한다. 고객 기준이라고 생각하기. 항상 기준은 Client(고객)이 왕이다.
- Server(주세요), Client(줄게요!)
- 정보의 교환이 목적이다 보니 대부분 Get(주세요), Post(줄게요)로 구현이 가능하다.

## 3. STATE(상태)

- 1) Clinet(POST) -> Server
- 2) Client <- Server
- 3) Client(POST) -> Server

> 3은 1에서 무슨 정보를 서버에게 주었는지 기억하지 못한다. HTTP는 기억 능력이 없다. 네이버에 로그인 하고, 이후에 요청할 때 이전 로그인에 대한 정보를 저장하지 않는다. -> 쿠키(클라이언트), 세션(서버) 등의 방법이 나왔다.

## 4. 간단한 Flask를 통해 Get, Post 이해하기

### index.html
```
<html>
  <head>
    <title>Elice</title>
  </head>
    <!-- app.py에서 user_id를 받아온다 -->
    <!-- Flask에서 template을 이용하는 독특한 방법이 있다. -->
  <body>
    <h1>Index.html</h1>
    <p>{{ user_id }}</p>
  </body>
</html>
```

### home.html
```
<!doctype html>
<html>
<head>
<title>Home</title>
</head>
<body>
    <h1>Home.html</h1>
    {% for title in titles %}
    <p>{{ title }}</p>
    {% endfor %}

    <form action='/register' method="POST">
    id <input type="text" name="user_id"/>
    password <input type="password" name="user_pw"/>
    <input type="submit">
    </form>
    
    <a href="{{ url_for('elice') }}">Go to Elice page</a> 
    <!-- elice()를 실행하라, 경로를 찾는게 아닌 app.py에 있는 함수를 찾는 것이다. -->

</body>
</html>
```

### app.py
```
# 기본 flask 구조에 대해 익혀보아요!
# 파이썬으로 서버를 개발한다고 하면 1. Flask(소규모), 2. Django(대규모)
from flask import Flask, render_template, request, url_for
# request는 사용자의 정보를 가져오거나, 줄 때 사용하는 클래스


app = Flask(__name__) # Flask라는 객체를 만들기. 
# __name__ 은 현재 실행하고 있는 파일을 가르키고 있는 파이썬의 문법이다.
# 현재는 app.py를 가르킨다, app.py를 플라스크 서버로 설정한다


# @app.route('/', method=['GET'])이 default이다. 클라이언트가 get을 한다고 생각하기! 
@app.route('/') # @ : 데코레이터. route는 URL 경로를 의미한다. 해당 주소를 들어가면, 하단의 함수를 실행해라. 함수는 호출시 실행하는 것이 일반적이지만 Flask는 정의만 한다.
@app.route('/home') # home으로 들어온 사람에게도 '/'로 들어온 사람과 같은 것을 반환한다.
def home():
    titles = ['Elice Flask class day1', 'haram good']
    return render_template("home.html", titles = titles) # 기본경로로 들어오면 home.html을 반환하겠다. 다만 반드시 같은 경로의 templates라는 폴더 안에 있어야한다.
    # 클라이언트(브라우저) 입장에서는 home.html이 어디있는지 관심 없다. 서버가 알아서 template폴더에서 찾아서 반환한다.


# @app.route('/user') 
# def user():
#     # 미리 만들어 놓은 html을 반환하고 싶으면 어떻게할까? 
#         # render_template 이용
#     return render_template("index.html")

# 유저가 100명일 때 각 유저에 대한 정보를 보여주고 싶을 땐? API를 활용
@app.route('/user/<username>')
def user(username): # 함수에서 인자도 받아와야한다.
    print(username) # 터미널에 기록을 남기는 print는 로그 용으로 사용하곤 한다.
    return render_template("index.html", user_id = username) # 템플릿 문법

@app.route('/elice') 
def elice():
    return "Hello elice"


# 회원가입, html의 form 태그를 이용
@app.route('/register', methods = ['POST']) # 클라이언트 정보를 줄게요
def register() :
    username = request.form['user_id'] # home.html이 아니라, 어느 html에서든 post를 user_id로 한 것을 찾는다.
    password = request.form['user_pw']
    print(username, password)
    return "Registered!" # 입력 완료 후 /register로 이동하게 된다.

if __name__ == "__main__":
    app.run(debug=True)
```

# Hash

```
# HASH란 무엇인지 살펴봅시다 :)
# 닭 -> 치킨 : 가능 / 치킨 -> 닭 : 불가능, 단 방향성 암호화이다. rainbow table 등의 해킹 기법이 있기는 하다.
# 같은 닭이지만 만들어지는 치킨은 항상 다르다. 
import secrets
from werkzeug.security import generate_password_hash, check_password_hash

# print(secrets.token_hex(16))

chicken = "rohharam"
name = "haram"
fried_chicken_1 = generate_password_hash(chicken) # chicken : 닭, fried_chicken_1 : 치킨
fried_chicken_2 = generate_password_hash(chicken)
print(fried_chicken_1)
print(fried_chicken_2)

print(check_password_hash(fried_chicken_1, chicken)) # 치킨으로 프라이드 치킨 만든게 맞는지 체크
print(check_password_hash(fried_chicken_2, name))
```


